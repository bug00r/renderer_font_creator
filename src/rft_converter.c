#include "rft_converter.h"

/* INFO: SET CHARSIZE

			error = FT_Set_Pixel_Sizes(
					face,   	// handle to face object 
					0,      	// pixel_width           
					hPixel );   // pixel_height          

			error = FT_Set_Char_Size(
					face,    // handle to face object           
					0,       // char_width in 1/64th of points  
					16*64,   // char_height in 1/64th of points 
					300,     // horizontal device resolution    
					300 );   // vertical device resolution   


	Test:
			//9 2   %
		static unsigned char ArialBold12_37[] = {
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4, 0x0, 0xa4, 0x0, 0xa8, 0x0, 0xa8, 0x0, 0xef, 0x0, 0x15, 0x0, 0x15, 0x0, 0x25, 0x0, 0x27, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
		};

		
		static unsigned char ArialBold12_64[] = {
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0, 0x30, 0xc0, 0x4d, 0xe0, 0x5f, 0xa0, 0xb3, 0x20, 0xb3, 0x20, 0xb3, 0x20, 0xbf, 0x40, 0x9b, 0x80, 0x40, 0x20, 0x20, 0x40, 0x1f, 0x80
		};
		
		unsigned char *arr = &ArialBold12_64[0];
		for ( int i = 0; i < 29; i+=2) {
			__rft_printBits(arr[i]);
			__rft_printBits(arr[i+1]);
			//printf("\n");
		}
		


*/

/*
 *  FILE PRINT METHODS  
 * */

char EMPTY_ENTRY;

//struct for printcache
typedef struct {
	char *fontname;
	char *fontfilename;
	char *familyname;
	FT_ULong startCode;
	FT_ULong endCode;
	FT_ULong cntCodes;
	char **font_info_entries;
	char * empty_glyph;
	unsigned char* fullbuff;
	FILE *out_file;
	int emptyWasSet;
} rft_pcache_t;

void __rft_pcache_free(rft_pcache_t *cache) {
	free(cache->fontname);
	free(cache->fontfilename);
	free(cache->familyname);

	for ( unsigned int curIdx = 0 ; curIdx < cache->cntCodes; curIdx++ ) {
		char * entry = cache->font_info_entries[curIdx];
		if ( entry != &EMPTY_ENTRY ) {
			free(cache->font_info_entries[curIdx]);
		}
	} 

	free(cache->empty_glyph);
	free(cache->font_info_entries);
	free(cache->fullbuff);
}

void __rft_pcache_init(rft_pcache_t *cache) {
	cache->fontname = NULL;
	cache->fontfilename = NULL;
	cache->familyname = NULL;
	cache->emptyWasSet = 0;
	cache->out_file = NULL;
	cache->startCode = 0UL;
	cache->endCode = 0UL;
	cache->cntCodes = 0UL;
	cache->font_info_entries = NULL;
	cache->fullbuff = NULL;
	cache->empty_glyph = NULL;
}

char * __rft_format_string_new(const char * msg, ...) {
	va_list vl;
	va_start(vl, msg);
	int buffsize = vsnprintf(NULL, 0, msg, vl);
	va_end(vl);
	buffsize += 1;
	char * buffer = malloc(buffsize);
	va_start(vl, msg);
	vsnprintf(buffer, buffsize, msg, vl);
	va_end( vl);
	return buffer;
}

void __rft_replace_string(char * string, char src, char replace) {

	char *str = string;
	int len = strlen(str);
	for ( int curChrIdx = 0; curChrIdx < len; curChrIdx++ ) {
		if ( str[curChrIdx] == src ) str[curChrIdx] = replace;
	}
}

void __rft_create_font_name_test(rft_pcache_t *cache, const char *family_name, int size) {
	cache->familyname = __rft_format_string_new("%s", family_name);
	__rft_replace_string(cache->familyname, ' ', '_');
	cache->fontname = __rft_format_string_new("%s%s%i", cache->familyname, "TestStyle", size);
}

void __rft_create_font_name(rft_pcache_t *cache, FT_Face font_face, int size) {
	cache->familyname = __rft_format_string_new("%s", font_face->family_name);
	__rft_replace_string(cache->familyname, ' ', '_');
	cache->fontname = __rft_format_string_new("%s%s%i", cache->familyname, font_face->style_name, size);
}

void __rft_create_font_file_name(rft_pcache_t *cache) {
	cache->fontfilename = __rft_format_string_new("font_%s.c", cache->fontname);
}

void __rft_create_font_info_entry_empty(rft_pcache_t *cache, int wPixel, int cntBytes, FT_ULong curChar) {
	char * newentry = __rft_format_string_new("\t{%i, %i, %s_empty}", wPixel, cntBytes, cache->fontname);
	cache->font_info_entries[curChar - cache->startCode] = newentry;
}

void __rft_create_font_info_entry(rft_pcache_t *cache, FT_ULong curChar, int wPixel, int cntBytes) {
	char * newentry = __rft_format_string_new("\t{%i, %i, %s_%lx}", wPixel, cntBytes, cache->fontname, curChar);
	cache->font_info_entries[curChar - cache->startCode] = newentry;
}

void __rft_print_header(rft_pcache_t *cache) {
	fprintf(cache->out_file, "// generated by %s\n//font: %s\n\n", __FILE__, cache->fontname);
	fprintf(cache->out_file,"#include \"font.h\"\n\n#ifndef NULL\n\t#define NULL 0\n#endif\n\n");
	fprintf(cache->out_file,"#ifndef CONST_DECL\n\t#define CONST_DECL const\n#endif\n\n");
}

void __rft_set_charcode_range(rft_pcache_t *_cache, FT_ULong startCharcode, FT_ULong endCharcode) {
	rft_pcache_t *cache = _cache;
	cache->startCode = startCharcode;
	cache->endCode = endCharcode;
	cache->cntCodes = endCharcode - startCharcode + 1; // +1 including last Sign
	size_t bufferSize = cache->cntCodes * sizeof(char *);
	cache->font_info_entries = malloc(bufferSize);
	//unfortunately setting an array of pointer to an address with memset seems not working
	//memset(cache->font_info_entries, (intptr_t)(void*)&EMPTY_ENTRY, bufferSize);
	//so i try the old fashion style init
	for ( size_t curBufferIdx = 0; curBufferIdx < cache->cntCodes; curBufferIdx++ )  { cache->font_info_entries[curBufferIdx] = &EMPTY_ENTRY; }
	//printf("size FT_LONG: %zu CNT CODES: %lx(%lu) - %lx(%lu) = %lx(%lu)\n", sizeof(FT_ULong), cache->endCode , cache->endCode, cache->startCode,   cache->startCode, cache->cntCodes, cache->cntCodes);
}

void __rft_print_font_info_array_start(rft_pcache_t *cache) {
	fprintf(cache->out_file,"CONST_DECL FO_FontInfo %sInfos[] = {\n", cache->fontname);
}

void __rft_print_font_info_array_end(rft_pcache_t *cache) {
	fprintf(cache->out_file,"};\n\n");
}

void __rft_print_charcode_array_start(rft_pcache_t *cache, FT_ULong curChar, int isempty) {
	if ( isempty == 0 ) {
		fprintf(cache->out_file,"CONST_DECL static unsigned char %s_%lx[] = {\n\t", cache->fontname, curChar);
	} else {
		fprintf(cache->out_file,"CONST_DECL static unsigned char %s_empty[] = {\n\t", cache->fontname);
	}
	
}

void __rft_print_font_properties(rft_pcache_t *cache, int hPixel) {
	fprintf(cache->out_file,"FO_FontProperties %sProperties = { %lu, %lu, &%sInfos[0], NULL, 0, %i };\n\n", 
							cache->fontname, cache->startCode, cache->endCode, cache->fontname, hPixel);
}

void __rft_print_font(rft_pcache_t *cache, int hPixel) {
	fprintf(cache->out_file,"CONST_DECL FO_Font FONT_%s  = { \n\t\"%s\",\n\t%i,\n\t%i,\n\t&%sProperties,\n\t%i \n};\n\n", 
							cache->familyname, cache->familyname, 0, hPixel ,cache->fontname, 1);
}

void __rft_print_byte(rft_pcache_t *cache, FT_ULong curChar) {
	fprintf(cache->out_file,"0x%lx", curChar);
}

void __rft_print_comma(rft_pcache_t *cache) {
	fprintf(cache->out_file,", ");
}

void __rft_print_newline(rft_pcache_t *cache) {
	fprintf(cache->out_file,"\n");
}

void __rft_print_charcode_array_end(rft_pcache_t *cache) {
	fprintf(cache->out_file,"\n};\n\n");
}

/**
 *  EOF FILE PRINT METHODS  
 * */


static void __rft_printBits(unsigned char num){
    unsigned int size = sizeof(unsigned char);
    unsigned int maxPow = 1<<(size*8-1);
    unsigned int i=0;
	for(;i<size*8;++i){
		// print last bit and shift left.
		printf("%u ",num&maxPow ? 1 : 0);
		num = num<<1;
	}
}

static void __rft_reset_buffer(unsigned char *buffer, unsigned int buffsize) {
	memset(buffer, 0, buffsize * sizeof(unsigned char));
}


void __rft_fullsize_copy(int hPixel, FT_Bitmap *bitmap, FT_GlyphSlot glyphSlot, int *wPixelMax, rft_pcache_t *pCache) {

	//unsigned char *fullbuff = pCache->fullbuff; //malloc((hPixel*hPixel)*sizeof(unsigned char));
	__rft_reset_buffer(pCache->fullbuff, hPixel*hPixel);

	//join both with offset
	int leftOffset = glyphSlot->bitmap_left;
	int topOffset = hPixel - glyphSlot->bitmap_top - bitmap->rows;
	topOffset = topOffset < 0 ? 0 : topOffset;

	//printf("wPixel: %i, bmp w/h: %i/%i offset T/L: %i/%i\n", hPixel, bitmap->width, bitmap->rows, topOffset, leftOffset);
	for (unsigned int row = 0; row < bitmap->rows; row++) {
		int rowIdx = row * bitmap->width;
		int targetRowIdx = (row + topOffset) * hPixel; 
		int targetColIdx = targetRowIdx + leftOffset;
		for (unsigned int w = 0; w < bitmap->width; w++) {
			int wIdx = targetColIdx + w;
			//printf("row/ridx: %i/%i font_w: %i target_idx:%i\n", row, targetRowIdx, w, wIdx);
			pCache->fullbuff[wIdx] = bitmap->buffer[rowIdx + w];
			if ( pCache->fullbuff[wIdx] == 1 ) {
				int curW = leftOffset + w;
				*wPixelMax = (*wPixelMax <= curW ? curW : *wPixelMax); 
			}
		}
	}

	if ( *wPixelMax == 0 ) *wPixelMax = bitmap->width - 1;

	/*for (unsigned int row = 0; row < hPixel; row++) {
		for (unsigned int w = 0; w < hPixel; w++) {
			printf(" %i", pCache->fullbuff[(row * hPixel) + w]);
		
		}
		printf("\n");
	}*/
	
}

static void __rft_print_byte_array_and_set_fi_entry(rft_conv_param_t* params, rft_pcache_t *pCache, unsigned char *byteBuffer, int hPixel, int wBytes, int wPixelMax, FT_ULong charcode, int isempty) {
	//printf("charcode: %lx\n", charcode);
	__rft_print_charcode_array_start(pCache, charcode, isempty);
	for ( int row = 0; row < hPixel; row++ ) 
	{
		unsigned int rowByteOffset = row * wBytes;
		for ( int byt = 0; byt < wBytes; byt++ ) 
		{
			unsigned char curChar = byteBuffer[rowByteOffset + byt];
			
			if ( params->verbose == 1) __rft_printBits(curChar);
			
			__rft_print_byte(pCache, curChar);
			if ( !(((byt + 1) == wBytes) && ((row + 1) == hPixel )) ) 
			{
				__rft_print_comma(pCache);
			}
		}
		
		if ( params->verbose == 1) printf("\n");
	}
	__rft_print_charcode_array_end(pCache);
	__rft_create_font_info_entry(pCache, charcode, wPixelMax, wBytes);
}

static void __rft_print_byte_array_and_set_fi_entry_empty(rft_conv_param_t* params, rft_pcache_t *pCache, int hPixel, int wBytes, int wPixelMax, FT_ULong charcode) {
	if ( pCache->emptyWasSet == 0 ) 
	{
		pCache->emptyWasSet = 1;
		size_t buffersize = params->hPixel * sizeof(unsigned char);
		unsigned char *byteBuffer = malloc(buffersize);
		memset(byteBuffer, 0xFF, buffersize);
		__rft_print_byte_array_and_set_fi_entry(params, pCache, byteBuffer, hPixel, 1, 8, charcode, 1);
		free(byteBuffer);
	}
	__rft_create_font_info_entry_empty(pCache, wPixelMax, wBytes, charcode);
}

static void __rft_prepare_bits(rft_conv_param_t* params, int hPixel, FT_Bitmap *_bitmap, FT_GlyphSlot glyphSlot, FT_ULong charcode, rft_pcache_t *pCache) {

	int wPixelMax = 0;
	FT_Bitmap *bitmap = _bitmap;
	
	__rft_fullsize_copy(hPixel, bitmap, glyphSlot, &wPixelMax, pCache);

	int wPixelRest = wPixelMax % 8;
	int wBytes 	   = wPixelMax / 8;

	if ( wPixelRest > 0 ) ++wBytes;
	
	int bufferSize = wBytes * hPixel;
	
	//printf("wPrest: %i, wBytes: %i, cntBytes: %i\n", wPixelRest, wBytes, bufferSize);
	//printf("cntBytes: %i\n", bufferSize);

	unsigned char *byteBuffer = malloc(bufferSize * sizeof(unsigned char));
	__rft_reset_buffer(byteBuffer, bufferSize);

	//FT_Glyph_Metrics *metrics = &glyphSlot->metrics; 
	//printf("FT Metrics\n");
	//printf("w: %i h: %i\n", metrics->width, metrics->height);
	//printf("hori Advanced: %i \n", metrics->horiAdvance);
	//printf("hori Bearing:  x: %i y: %i\n", metrics->horiBearingX, metrics->horiBearingY);
	//printf("verti Advanced: %i \n", metrics->vertAdvance);
	//printf("verti Bearing:  x: %i y: %i\n", metrics->vertBearingX, metrics->vertBearingY);
	//printf("wPixelMax: %i\n", wPixelMax);
	
	for (int row = 0; row < hPixel; row++ ) {
		unsigned int rowIx = row * hPixel;
		unsigned int rowByteOffset = row * wBytes;
		for (int bit = 0; bit <= wPixelMax; bit++) {
			unsigned int curIdx = rowIx + bit;
			unsigned int curByteIdx = rowByteOffset + ( bit / 8 );
			unsigned int curByteBitIdx = 7 - ( bit % 8 );
			unsigned int curBitValue = pCache->fullbuff[curIdx];

			byteBuffer[curByteIdx] |= ( (unsigned char)curBitValue << curByteBitIdx );
			
		}

	}
	
	__rft_print_byte_array_and_set_fi_entry(params, pCache, byteBuffer, hPixel, wBytes, wPixelMax, charcode, 0);

	free(byteBuffer);
}

void __rft_print_bitmap(FT_Bitmap *bitmap) {
	printf("bitmap attributes:\nrows: %u\nwidth: %u\npitch:%i\npixelmode: %i\n", bitmap->rows, bitmap->width, bitmap->pitch, bitmap->pixel_mode);
}

void __rft_process_charcode(rft_conv_param_t* params, FT_Library  _library, FT_Face _face, int hPixel, rft_pcache_t *pCache, FT_ULong charcode) {

	FT_Error error;
	FT_Library  library = _library;
	FT_Face face = _face;
	//printf("searching charcode: %lx\n", charcode);
	FT_UInt glyphIdx = FT_Get_Char_Index(face, charcode);

	if ( glyphIdx == 0 ) {
		printf("%u not found :(\n", glyphIdx);
	} else {
		//printf("%lx found at idx %i...loading Glyph\n", charcode, glyphIdx);
		error = FT_Load_Glyph(face, glyphIdx, FT_LOAD_DEFAULT );
		if ( error ) {
			printf("something went wrong during loading: %x\n", error);
		} else {
			//printf("glyph loaded ok\n");
			/* not rendered, render it now */
			FT_GlyphSlot glyphSlot = face->glyph;
			//if ( glyphSlot->format != FT_GLYPH_FORMAT_BITMAP ) {
			error = FT_Render_Glyph( face->glyph,   /* glyph slot  */
										FT_RENDER_MODE_MONO); /* render mode */
			if ( error ) {
				printf("something went wrong during rendering: %x\n", error);
			} else {
				
				FT_Bitmap *bitmap_ = &glyphSlot->bitmap;

				FT_Bitmap bitmap;
				FT_Bitmap_Init(&bitmap);
				
				error = FT_Bitmap_Convert(library, bitmap_, &bitmap, 1 );

				if ( error ) {
					printf("bmp convert Issue: %x\n", error);
				}		  

				if ( params->verbose == 1) {
					printf("glyph left: %i\ntop: %i\n", glyphSlot->bitmap_left, glyphSlot->bitmap_top);

					printf("Bitmap data:\n");
					for (unsigned int row = 0; row < bitmap.rows; row++) {
						for (unsigned int w = 0; w < bitmap.width; w++) {
							printf(" %i", bitmap.buffer[(row * bitmap.width) + w]);
						}
						printf("\n");
					}
				}
				

				__rft_prepare_bits(params, hPixel, &bitmap, glyphSlot, charcode, pCache);

				FT_Bitmap_Done(library, &bitmap);
			}
			//}
			FT_Glyph glyph;
			FT_Get_Glyph(glyphSlot, &glyph);
			FT_Done_Glyph(glyph);
		}
	}
}

static void __rft_process_font_face(rft_conv_param_t* params, FT_Library  library, rft_pcache_t *pCache, FT_ULong charcode) {

	FT_Error error;

	rft_conv_font_param_t* font_param = rft_conv_font_by_charcode(params, charcode);

	if ( font_param == NULL ) {
		__rft_print_byte_array_and_set_fi_entry_empty(params, pCache, params->hPixel, 1, 8, charcode);		
		return;
	}

	FT_Face face;
	error = FT_New_Face( library, font_param->fontfile, font_param->faceIndex, &face);
	
	if ( error > 0 )
	{
		fprintf(stderr, "FontFace error: %s\n", FT_Error_String(error));
	} else {
		//printf("loaded:\nfamily: %s\nstyle: %s\nglyphs: %li\n", face->family_name, face->style_name, face->num_glyphs);

		int hPixel = params->hPixel;

		/* INFO: SET CHARSIZE */
		error = FT_Set_Pixel_Sizes(
							face,   /* handle to face object */
							0,      /* pixel_width           */
							hPixel );   /* pixel_height          */
		
		if ( error > 0 ) {
			fprintf(stderr, "Set Pixel error: %s\n", FT_Error_String(error));
		}

		//FT_ULong startCharcode = 0x4E00;
		//FT_ULong charcode = 0x4E1F;
		//FT_ULong charcode = 0x4E01;
		//FT_ULong charcode = 0x4FF7;
		//FT_ULong startCharcode = 0x4E20;
		//FT_ULong charcode = 0x706C;
		//FT_ULong endCharcode = 0x4E2C;
		//FT_ULong endCharcode = 0x9FA5;
		
		//for ( FT_ULong curCharcode = pCache->startCode; curCharcode <= pCache->endCode; curCharcode++ ) {
		__rft_process_charcode(params, library, face, hPixel, pCache, charcode);
		//}

		//old pCache cleanup

		FT_Done_Face(face);
	}

}

void printf_init( rft_conv_param_t* params )
{
	printf("init font converter\n");
	printf("verbose: %i \n", params->verbose);
    printf("help: %i \n", params->showHelp);
    printf("hex: %i \n", params->hex);
    printf("minCharcode: %lu \n", params->minCharcode);
    printf("maxCharcode: %lu \n", params->maxCharcode);
    printf("hPixel: %i \n", params->hPixel);
    printf("#fonts: %i \n", params->cntFonts);

	int hPixel = params->hPixel;

	FT_Library  library;


	FT_Error error = FT_Init_FreeType( &library );
	if ( error > 0 )
	{
		fprintf(stderr, "Init FT error: %s\n", FT_Error_String(error));
	} else {
		
		rft_pcache_t *pCache = malloc(sizeof(rft_pcache_t));
		__rft_pcache_init(pCache);
		__rft_create_font_name_test(pCache,"MyChineseMix", hPixel);
		//__rft_create_font_name(pCache, "mytest", hPixel);
		__rft_create_font_file_name(pCache);
		pCache->fullbuff = malloc((hPixel*hPixel) * sizeof(unsigned char));
		pCache->empty_glyph = calloc((hPixel*8) * sizeof(unsigned char), 0);

		pCache->out_file = fopen(pCache->fontfilename, "w");

		__rft_print_header(pCache);

		__rft_set_charcode_range(pCache, params->minCharcode, params->maxCharcode);

		for ( FT_ULong curCharcode = params->minCharcode; curCharcode <= params->maxCharcode ; curCharcode++ ) {
			__rft_process_font_face(params, library, pCache, curCharcode);
		}

		__rft_print_font_info_array_start(pCache);
		for ( unsigned int curIdx = 0; curIdx < pCache->cntCodes; curIdx++ ) {
			
			char *entry = pCache->font_info_entries[curIdx];

			entry = ( entry != &EMPTY_ENTRY ? entry : pCache->empty_glyph);

			fprintf(pCache->out_file,"%s", entry);

			if ( (curIdx + 1) < pCache->cntCodes )  {
				__rft_print_comma(pCache);
			}
			__rft_print_newline(pCache);
				
		}
		__rft_print_font_info_array_end(pCache);

		__rft_print_font_properties(pCache, hPixel);

		__rft_print_font(pCache, hPixel);

		fclose(pCache->out_file);

		__rft_pcache_free(pCache);

		free(pCache);

		FT_Done_FreeType(library);
	}
}
